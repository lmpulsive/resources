<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Diablo 3 Clone</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* General Reset and Body/HTML Styling */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent scrolling */
            background: #000; /* Black background */
            font-family: 'Courier New', monospace; /* Themed font */
            color: #ff6600; /* Diablo-style orange text */
            touch-action: none; /* Disable default touch actions for game responsiveness */
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            position: fixed; /* Ensures content fills screen without issues */
        }
        
        /* Game Container to hold canvas and UI */
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Use dynamic viewport height for mobile browsers with varying address bar heights */
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100); 
            background: #000;
            overflow: hidden;
        }
        
        /* Three.js Canvas Styling */
        #gameCanvas {
            display: block !important;
            width: 100% !important;
            height: 100% !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            object-fit: contain; /* Keep aspect ratio, might show black bars */
            background: #000;
        }
        
        /* UI Layer */
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            height: calc(var(--vh, 1vh) * 100); /* Consistent mobile height */
            z-index: 10;
            pointer-events: none; /* Allow clicks to pass through to canvas unless on specific elements */
            /* Handle iPhone safe areas for UI padding */
            padding-top: env(safe-area-inset-top, 0);
            padding-bottom: env(safe-area-inset-bottom, 0);
            padding-left: env(safe-area-inset-left, 0);
            padding-right: env(safe-area-inset-right, 0);
        }
        
        /* Health Bar */
        .health-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 180px;
            height: 18px;
            background: rgba(0,0,0,0.9); /* Semi-transparent black */
            border: 2px solid #8B0000; /* Dark red border */
            pointer-events: none;
            border-radius: 3px;
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.4);
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600); /* Red to orange gradient */
            transition: width 0.3s ease; /* Smooth width transition */
            border-radius: 1px;
        }
        
        /* Mana Bar */
        .mana-bar {
            position: absolute;
            top: 45px;
            left: 20px;
            width: 180px;
            height: 18px;
            background: rgba(0,0,0,0.9);
            border: 2px solid #000080; /* Dark blue border */
            pointer-events: none;
            border-radius: 3px;
            box-shadow: 0 0 8px rgba(0, 0, 255, 0.4);
        }
        
        .mana-fill {
            height: 100%;
            background: linear-gradient(90deg, #0000ff, #4169E1); /* Blue to royal blue gradient */
            transition: width 0.3s ease;
            border-radius: 1px;
        }
        
        /* Player Stats */
        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #ffaa00; /* Golden orange */
            font-size: 13px;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        /* Fullscreen Button */
        .fullscreen-btn {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 40px;
            height: 30px;
            background: rgba(255, 102, 0, 0.8); /* Semi-transparent orange */
            border: 1px solid #ffaa00;
            border-radius: 4px;
            color: white;
            font-size: 10px;
            cursor: pointer;
            pointer-events: auto; /* Allow clicks */
            text-align: center;
            line-height: 28px;
            user-select: none;
            transition: background 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        
        .fullscreen-btn:hover {
            background: rgba(255, 102, 0, 1);
        }
        
        /* Action Bar (abilities/spells) */
        .action-bar {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3 columns */
            grid-template-rows: repeat(2, 1fr); /* 2 rows */
            gap: 6px; /* Spacing between slots */
            pointer-events: auto; /* Allow clicks */
            background: rgba(0, 0, 0, 0.9);
            padding: 8px;
            border-radius: 12px;
            border: 2px solid #ff6600;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.8);
        }
        
        .action-slot {
            width: 50px;
            height: 50px;
            background: rgba(20, 20, 20, 0.9);
            border: 2px solid #666;
            border-radius: 8px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px; /* For icons/emojis */
            user-select: none;
            touch-action: manipulation; /* Allow touch to trigger click */
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        
        .action-slot:hover {
            border-color: #ffaa00;
            background: rgba(40, 40, 40, 0.9);
            transform: scale(1.05);
        }
        
        .action-slot:active {
            transform: scale(0.95);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.6);
        }
        
        /* Cooldown and Disabled states */
        .action-slot.on-cooldown {
            opacity: 0.6; /* Dim during cooldown */
            border-color: #444;
            cursor: not-allowed;
        }
        
        .action-slot.insufficient-mana {
            border-color: #800080; /* Purple for insufficient mana */
            background: rgba(80, 0, 80, 0.3);
            cursor: not-allowed;
        }
        
        .action-slot.disabled { /* Used for general disabled state */
            opacity: 0.4;
            background: rgba(100, 100, 100, 0.8);
            color: #ccc;
            cursor: not-allowed;
        }
        
        .action-hotkey {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 10px;
            color: #ffaa00;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.8);
            padding: 1px 3px;
            border-radius: 2px;
        }
        
        .action-cooldown {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8); /* Dark overlay during cooldown */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            font-weight: bold;
            border-radius: 6px;
        }
        
        /* In-game Instructions */
        .instructions {
            position: absolute;
            bottom: 200px;
            left: 20px;
            color: #ffaa00;
            font-size: 11px;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.7);
            padding: 5px;
            border-radius: 3px;
            border: 1px solid rgba(255, 102, 0, 0.5);
            box-shadow: 0 0 10px rgba(255, 102, 0, 0.3);
        }
        
        /* Floating Damage Text */
        .damage-text {
            position: absolute;
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            pointer-events: none;
            animation: damageFloat 1s ease-out forwards;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
        }
        
        @keyframes damageFloat {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }
        
        /* Mobile Controls Container */
        .mobile-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 160px; /* Provides space for joystick and ensures UI is above safe area */
            z-index: 20;
            pointer-events: none;
            /* Handle iPhone safe areas for joystick/buttons */
            padding-bottom: env(safe-area-inset-bottom, 10px);
            padding-left: env(safe-area-inset-left, 0);
            padding-right: env(safe-area-inset-right, 0);
        }
        
        /* Virtual Joystick - Twice as big and slightly offset */
        .virtual-joystick {
            position: absolute;
            bottom: 40px; /* Increased offset from bottom */
            left: 40px; /* Increased offset from left */
            width: 240px; /* Twice as big */
            height: 240px; /* Twice as big */
            background: rgba(255, 255, 255, 0.15); /* Transparent white base */
            border: 2px solid rgba(255, 102, 0, 0.6);
            border-radius: 50%;
            pointer-events: auto; /* Allow touch/mouse interaction */
            touch-action: none; /* Prevent scrolling/zooming */
            box-shadow: 0 0 10px rgba(255, 102, 0, 0.3);
        }
        
        .joystick-knob {
            position: absolute;
            width: 80px; /* Twice as big */
            height: 80px; /* Twice as big */
            background: rgba(255, 102, 0, 0.9); /* Orange knob */
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Center the knob initially */
            transition: none; /* No transition for direct movement */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        /* Game Over Message */
        #gameOverMessage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: #ff6600;
            font-size: 3em;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 200;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.8);
            pointer-events: all; /* Allow clicks on buttons within */
            display: none; /* Hidden by default */
        }

        #gameOverMessage button {
            background: #ff6600;
            color: white;
            border: 2px solid #ffaa00;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.6em;
            margin-top: 20px;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        #gameOverMessage button:hover {
            background: #ffaa00;
            transform: translateY(-2px);
        }

        #gameOverMessage button:active {
            transform: translateY(0);
        }
        
        /* --- Responsive adjustments --- */
        
        /* For screens up to 768px wide (typical tablets and large phones) */
        @media (max-width: 768px) {
            .health-bar, .mana-bar {
                width: 140px;
                height: 16px;
            }
            
            .stats {
                font-size: 11px;
            }
            
            .instructions {
                font-size: 10px;
                bottom: 220px; /* Push up due to larger mobile controls area */
            }
            
            .action-bar {
                bottom: 15px;
                right: 15px;
                gap: 4px;
                padding: 6px;
                border-width: 3px;
            }
            
            .action-slot {
                width: 45px;
                height: 45px;
                font-size: 20px;
                border-width: 2px;
            }
            
            .action-hotkey {
                font-size: 9px;
                bottom: 1px;
                right: 3px;
            }
            
            .virtual-joystick {
                width: 200px; /* Adjusted size for smaller tablets - half of original desktop doubled size */
                height: 200px; /* Adjusted size for smaller tablets */
                bottom: 30px; /* Adjusted offset */
                left: 30px; /* Adjusted offset */
            }
            
            .joystick-knob {
                width: 60px; /* Adjusted size */
                height: 60px; /* Adjusted size */
            }
        }
        
        /* iPhone specific optimizations (e.g., iPhone 12 Pro Max: 428x926, iPhone X/XS: 375x812, etc.) */
        @media (max-width: 430px) and (max-height: 932px) {
            .health-bar, .mana-bar {
                width: 120px;
                height: 14px;
                left: 15px;
            }
            
            .mana-bar {
                top: 40px;
            }
            
            .stats {
                font-size: 10px;
                right: 15px;
            }
            
            .instructions {
                display: none; /* Hide on smaller phones to save space */
            }
            
            .action-bar {
                bottom: 10px;
                right: 10px;
                gap: 3px;
                padding: 4px;
                border-width: 2px;
                /* Account for safe area below action bar */
                margin-bottom: env(safe-area-inset-bottom, 0); 
            }
            
            .action-slot {
                width: 40px;
                height: 40px;
                font-size: 18px;
                border-width: 1px;
            }
            
            .action-hotkey {
                font-size: 8px;
                bottom: 0px;
                right: 2px;
            }
            
            .action-cooldown {
                font-size: 10px;
            }
            
            .virtual-joystick {
                width: 180px; /* Slightly smaller for very small phones */
                height: 180px; /* Slightly smaller for very small phones */
                bottom: 25px; /* Adjusted offset */
                left: 25px; /* Adjusted offset */
            }
            
            .joystick-knob {
                width: 50px; /* Adjusted size */
                height: 50px; /* Adjusted size */
            }
        }
        
        /* Hide mobile controls on larger screens (desktop) */
        @media (min-width: 769px) {
            .mobile-controls {
                display: none;
            }
            /* Adjust instructions position for desktop */
            .instructions {
                bottom: 80px; 
            }
        }
        
        /* Hide fullscreen button on mobile */
        @media (max-width: 768px) {
            .fullscreen-btn {
                display: none;
            }
        }
        
        /* Extra small mobile screens */
        @media (max-width: 360px) {
            .action-bar {
                bottom: 8px;
                right: 8px;
                gap: 2px;
                padding: 3px;
            }
            
            .action-slot {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
            
            .action-hotkey {
                font-size: 7px;
            }
             .virtual-joystick {
                width: 150px; 
                height: 150px; 
            }
            
            .joystick-knob {
                width: 40px; 
                height: 40px; 
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <!-- Health Bar UI -->
            <div class="health-bar">
                <div class="health-fill" id="healthFill" style="width: 100%"></div>
            </div>
            <!-- Mana Bar UI -->
            <div class="mana-bar">
                <div class="mana-fill" id="manaFill" style="width: 100%"></div>
            </div>
            <!-- Player Stats UI -->
            <div class="stats">
                <div>Level: <span id="level">1</span></div>
                <div>XP: <span id="xp">0</span> / <span id="xpNext">100</span></div>
                <div>Enemies: <span id="enemyCount">0</span></div>
            </div>
            <!-- Fullscreen Button -->
            <div class="fullscreen-btn" id="fullscreenBtn">‚õ∂</div>
            <!-- Game Instructions -->
            <div class="instructions">
                WASD: Move | Q: Attack | E: Special | 1-4: Spells<br>
                Right-click: Cast fireball at cursor | Action bar: Click abilities
            </div>
        </div>
        
        <!-- Action Bar (Desktop & Mobile) -->
        <div class="action-bar">
            <!-- Top row: Spells -->
            <div class="action-slot" id="spell1" data-spell="fireball">
                üî•
                <div class="action-hotkey">1</div>
                <div class="action-cooldown" style="display: none;"></div>
            </div>
            <div class="action-slot" id="spell2" data-spell="icestorm">
                ‚ùÑÔ∏è
                <div class="action-hotkey">2</div>
                <div class="action-cooldown" style="display: none;"></div>
            </div>
            <div class="action-slot" id="spell3" data-spell="lightning">
                ‚ö°
                <div class="action-hotkey">3</div>
                <div class="action-cooldown" style="display: none;"></div>
            </div>
            
            <!-- Bottom row: Combat + Utility -->
            <div class="action-slot" id="attackBtn" data-action="attack">
                ‚öîÔ∏è
                <div class="action-hotkey">Q</div>
                <div class="action-cooldown" style="display: none;"></div>
            </div>
            <div class="action-slot" id="specialBtn" data-action="special">
                üí•
                <div class="action-hotkey">E</div>
                <div class="action-cooldown" style="display: none;"></div>
            </div>
            <div class="action-slot" id="spell4" data-spell="teleport">
                üåÄ
                <div class="action-hotkey">4</div>
                <div class="action-cooldown" style="display: none;"></div>
            </div>
        </div>
        
        <!-- Mobile Controls (Joystick) -->
        <div class="mobile-controls">
            <div class="virtual-joystick" id="virtualJoystick">
                <div class="joystick-knob" id="joystickKnob"></div>
            </div>
        </div>

        <!-- Game Over Message Overlay -->
        <div id="gameOverMessage">
            Game Over!
            <button id="restartButton">Restart</button>
        </div>
    </div>

    <script>
        // --- Constants for Player Stats and Cooldowns ---
        const INITIAL_PLAYER_HEALTH = 100;
        const INITIAL_PLAYER_MANA = 100;
        const INITIAL_PLAYER_XP_NEXT = 100;
        const PLAYER_ATTACK_COOLDOWN_FRAMES = 30;

        // Global game state object to manage all game entities and variables
        const game = {
            scene: null, // Three.js scene
            camera: null, // Three.js camera
            renderer: null, // Three.js renderer
            player: {
                mesh: null, // Player's THREE.Sprite
                health: INITIAL_PLAYER_HEALTH, // Current health
                maxHealth: INITIAL_PLAYER_HEALTH, // Maximum health
                mana: INITIAL_PLAYER_MANA, // Current mana
                maxMana: INITIAL_PLAYER_MANA, // Maximum mana
                level: 1, // Player level
                xp: 0, // Current experience points
                xpNext: INITIAL_PLAYER_XP_NEXT, // XP needed for next level
                // Player's 3D position (center of the player model, Y will be set by createPlayer)
                position: new THREE.Vector3(0, 0, 0), 
                attackCooldown: 0, // Cooldown frames for basic attack
                rotation: 0, // Current Y-axis rotation (for conceptual direction)
                targetRotation: 0, // Target Y-axis rotation for smooth turning

                // --- Sprite Animation Properties ---
                animationState: 'idle', // 'idle', 'walk', 'attack', 'cast'
                currentFrame: 0,
                frameCounter: 0,
                frameRate: 8, // frames per second for continuous animations (idle, walk)
                animationTimers: { // To manage one-shot animations (attack, spell)
                    attack: { active: false, currentFrame: 0, startTime: 0, duration: 400 }, // Duration in ms for attack animation
                    spell: { active: false, currentFrame: 0, startTime: 0, duration: 600 } // Duration in ms for spell cast animation
                },
                // Define animation sequences as arrays of frame numbers
                animationSequences: {
                    idle: [0, 1], // Row 0, frames 0-1
                    walk: [2, 3], // Row 0, frames 2-3
                    attack: [4, 5, 6, 7], // Row 1, frames 4-7
                    cast: [8, 9, 10, 11] // Row 2, frames 8-11
                },
                spriteTexture: null // To store the loaded sprite sheet texture
            },
            enemies: [], // Array to hold all enemy objects
            spells: {
                active: [], // Array for active spell projectiles/effects
                types: { // Definitions for various spells
                    fireball: { damage: 40, manaCost: 15, cooldown: 1000, range: 20, targeted: true },
                    icestorm: { damage: 30, manaCost: 25, cooldown: 3000, range: 8, targeted: true },
                    lightning: { damage: 50, manaCost: 20, cooldown: 1500, range: 15, targeted: true },
                    teleport: { manaCost: 30, cooldown: 5000, range: 10, targeted: true },
                    shield: { duration: 10000, manaCost: 20, cooldown: 15000, targeted: false }, // Example of non-targeted spell
                    meteor: { damage: 80, manaCost: 40, cooldown: 8000, range: 12, targeted: true }
                },
                cooldowns: {} // Stores cooldown timestamps for spells
            },
            effects: [], // Array for various temporary visual effects (explosions, etc.)
            keys: {}, // Stores state of pressed keyboard keys
            mobile: {
                joystick: { active: false, deltaX: 0, deltaY: 0 }, // Joystick state
                isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) // Check for mobile device
            },
            raycaster: new THREE.Raycaster(), // Used for mouse/touch picking in 3D space
            groundMesh: null, // Reference to the ground plane for raycasting
            
            // --- Camera Fix Properties ---
            cameraOffset: new THREE.Vector3(15, 20, 15), // Original fixed offset
            cameraCurrentLookAt: new THREE.Vector3(0, 0, 0), // The point the camera will smoothly look at
            cameraLerpFactor: 0.05 // Controls how smoothly the camera follows (0-1, higher means faster)
        };

        // --- Three.js Initialization ---
        function initThreeJS() {
            const container = document.getElementById('gameContainer');
            
            // Get actual viewport dimensions, accounting for browser UI changes on mobile
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            // Scene: Where all 3D objects reside
            game.scene = new THREE.Scene();
            game.scene.background = new THREE.Color(0x0a0a0a); // Dark background
            game.scene.fog = new THREE.Fog(0x0a0a0a, 20, 100); // Fog for depth
            
            // Camera: How we view the scene
            game.camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            // Initial camera position will be updated by updateCamera() after player is created
            game.camera.position.set(10, 15, 10); 
            game.camera.lookAt(0, 0, 0); // Initial look at origin
            
            // Renderer: Renders the scene to the canvas
            game.renderer = new THREE.WebGLRenderer({ 
                antialias: true, // Smooth edges
                alpha: false, // No transparent background
                powerPreference: "high-performance" // Request high-performance GPU
            });
            
            // Set initial size of the renderer (canvas)
            game.renderer.setSize(width, height, false);
            // Set pixel ratio for sharp rendering on high-DPI screens
            game.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            game.renderer.shadowMap.enabled = true; // Enable shadows
            game.renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows
            game.renderer.domElement.id = 'gameCanvas'; // Assign ID to canvas element
            
            // Critical: Ensure the canvas takes up the full container space
            const canvas = game.renderer.domElement;
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.display = 'block'; // Ensure it's a block element
            
            container.appendChild(canvas); // Add canvas to the game container
            
            // Lighting: Provides illumination in the scene
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3); // Soft, global light
            game.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xff6600, 0.8); // Main light source, orange tint
            directionalLight.position.set(10, 20, 5); // Position of the light
            directionalLight.castShadow = true; // Enable light to cast shadows
            directionalLight.shadow.mapSize.width = 1024; // Shadow map resolution
            directionalLight.shadow.mapSize.height = 1024;
            game.scene.add(directionalLight);
            
            console.log('Three.js initialized successfully with dimensions:', width, 'x', height);
        }

        // --- Game World Creation ---
        function createWorld() {
            // Ground Plane
            const groundGeometry = new THREE.PlaneGeometry(100, 100); // Large flat plane
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x2a1810 }); // Dark brown material
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
            ground.receiveShadow = true; // Ground can receive shadows
            ground.name = 'ground'; // Assign a name for raycasting identification
            game.scene.add(ground);
            game.groundMesh = ground; // Store reference to ground for raycasting
            
            // Environment Pillars (obstacles/decorations)
            const pillarGeometry = new THREE.BoxGeometry(1, 6, 1); // Tall box shape
            const pillarMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 }); // Dark gray material
            
            for (let i = 0; i < 8; i++) {
                const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                const angle = (i / 8) * Math.PI * 2; // Distribute pillars in a circle
                pillar.position.set(Math.cos(angle) * 15, 3, Math.sin(angle) * 15); // Position relative to center
                pillar.castShadow = true; // Pillars cast shadows
                game.scene.add(pillar);
            }
            
            // Torches (point lights)
            for (let i = 0; i < 4; i++) {
                const torchGeometry = new THREE.BoxGeometry(0.5, 2, 0.5); // Simple torch pole
                const torchMaterial = new THREE.MeshBasicMaterial({ color: 0xff6600 }); // Orange basic material
                const torch = new THREE.Mesh(torchGeometry, torchMaterial);
                const angle = (i / 4) * Math.PI * 2;
                torch.position.set(Math.cos(angle) * 12, 1, Math.sin(angle) * 12);
                game.scene.add(torch);
                
                const torchLight = new THREE.PointLight(0xff6600, 0.5, 10); // Orange point light
                torchLight.position.copy(torch.position);
                torchLight.position.y += 1; // Light source slightly above torch mesh
                game.scene.add(torchLight);
            }
        }

        // --- Utility to set a specific frame on a THREE.Sprite's texture ---
        // cols and rows define the grid dimensions of the sprite sheet
        function setFrame(sprite, frameIndex, cols = 4, rows = 3) {
            if (!sprite || !sprite.material || !sprite.material.map) {
                console.warn("Sprite or its texture not ready for setFrame.", sprite);
                return;
            }
            const texture = sprite.material.map;

            // Calculate the size of a single frame in UV coordinates
            const frameU = 1 / cols;
            const frameV = 1 / rows;

            // Calculate the column and row of the current frame
            const col = frameIndex % cols;
            const row = Math.floor(frameIndex / cols);

            // Set the offset for the texture (UV coordinates)
            // texture.offset.x = column * frameU
            // texture.offset.y = 1 - frameV - (row * frameV) // textures are loaded bottom-up by default
            texture.offset.set(col * frameU, 1 - frameV - row * frameV);

            // Set the repeat for the texture to display only one frame
            texture.repeat.set(frameU, frameV);
        }

        // --- Player Creation (using THREE.Sprite and Sprite Sheet) ---
        function createPlayer() {
            // Desired visual height of the player sprite in 3D world units
            const desiredPlayerHeight = 2.5; 
            const SPRITE_SHEET_URL = 'sprites/player_spritesheet.png';

            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                SPRITE_SHEET_URL,
                (texture) => {
                    // Set texture filtering for pixel art look
                    texture.magFilter = THREE.NearestFilter;
                    texture.minFilter = THREE.NearestFilter;
                    game.player.spriteTexture = texture; // Store the texture for animation

                    // Create a SpriteMaterial with the loaded texture.
                    const playerMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true, alphaTest: 0.1 });
                    const playerSprite = new THREE.Sprite(playerMaterial);

                    // Based on 32x32 pixel frames, aspect ratio is 1:1.
                    // Set the scale of the sprite in 3D units.
                    playerSprite.scale.set(desiredPlayerHeight, desiredPlayerHeight, 1);

                    // The sprite's origin (pivot point) is its center. To place its base on the ground (y=0),
                    // its center must be at y = spriteHeight / 2.
                    game.player.position.set(0, desiredPlayerHeight / 2, 0); 
                    playerSprite.position.copy(game.player.position);

                    game.player.mesh = playerSprite; // Store reference to the new sprite
                    game.scene.add(playerSprite); // Add player sprite to the scene

                    // Initialize to the first frame (idle)
                    setFrame(game.player.mesh, game.player.animationSequences.idle[0]);

                    console.log('Player sprite created successfully with initial frame at Y:', game.player.position.y);
                },
                undefined, // onProgress callback
                (error) => {
                    console.error('Error loading player sprite texture:', error);
                    // Fallback: If texture loading fails, create a simple 3D placeholder
                    const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8); // Height 2
                    const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x0066ff }); // Blue body
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.castShadow = true;
                    
                    // For the 2-unit tall cylinder, its center is at y=1 when its base is at y=0.
                    game.player.position.set(0, 1, 0); 
                    body.position.copy(game.player.position);

                    game.player.mesh = body; // Store reference to the fallback mesh
                    game.scene.add(body);
                    console.log('Using fallback 3D player model at Y:', game.player.position.y);
                }
            );
        }

        // --- Enemy Creation ---
        function createEnemy() {
            const enemyGroup = new THREE.Group();
            
            // Enemy body
            const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.5, 6);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xff3333 }); // Red body
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            enemyGroup.add(body);
            
            // Enemy head
            const headGeometry = new THREE.SphereGeometry(0.25, 6, 6);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xff1111 }); // Darker red head
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1;
            enemyGroup.add(head);
            
            // Position enemy randomly around player
            const angle = Math.random() * Math.PI * 2;
            const distance = 8 + Math.random() * 15; // Random distance from player
            enemyGroup.position.set(
                Math.cos(angle) * distance,
                0.75, // Vertically offset for ground alignment (center of 1.5 unit tall enemy)
                Math.sin(angle) * distance
            );
            
            // Store enemy specific data in userData property
            enemyGroup.userData = {
                health: 30,
                maxHealth: 30,
                speed: 0.02,
                attackDamage: 5,
                xpValue: 25,
                lastAttack: 0, // Timestamp of last attack
                body: body, // Reference to body mesh for color changes
                head: head // Reference to head mesh
            };
            
            game.enemies.push(enemyGroup); // Add enemy to the game's enemy list
            game.scene.add(enemyGroup); // Add enemy to the scene
        }

        // --- Input Handling ---
        function handleInput() {
            const speed = 0.15;
            let moved = false;
            let moveX = 0;
            let moveZ = 0;
            
            // Keyboard input for movement
            if (game.keys['w'] || game.keys['W']) {
                moveZ -= 1;
                moved = true;
            }
            if (game.keys['s'] || game.keys['S']) {
                moveZ += 1;
                moved = true;
            }
            if (game.keys['a'] || game.keys['A']) {
                moveX -= 1;
                moved = true;
            }
            if (game.keys['d'] || game.keys['D']) {
                moveX += 1;
                moved = true;
            }
            
            // Mobile joystick input for movement
            if (Math.abs(game.mobile.joystick.deltaX) > 0.1 || Math.abs(game.mobile.joystick.deltaY) > 0.1) {
                moveX += game.mobile.joystick.deltaX;
                moveZ += game.mobile.joystick.deltaY;
                moved = true;
            }
            
            // Apply movement if player is moving
            if (moved) {
                // Normalize diagonal movement to prevent faster speed
                const magnitude = Math.sqrt(moveX * moveX + moveZ * moveZ);
                if (magnitude > 0) {
                    moveX = (moveX / magnitude) * speed;
                    moveZ = (moveZ / magnitude) * speed;
                    
                    // Update player's conceptual 3D position (center of the model)
                    game.player.position.x += moveX;
                    game.player.position.z += moveZ;
                    
                    // Set animation state to walk if not currently performing a one-shot animation
                    if (game.player.animationState !== 'attack' && game.player.animationState !== 'cast') {
                        game.player.animationState = 'walk';
                    }
                }
                
                // Update player mesh's position in the scene
                if (game.player.mesh) {
                    game.player.mesh.position.copy(game.player.position);
                    // THREE.Sprite automatically faces the camera, so no rotation.y needed
                    // If using a fallback 3D mesh:
                    if (game.player.mesh instanceof THREE.Group) { // Check if it's the fallback 3D model
                        // Calculate target rotation based on movement direction for 3D model
                        game.player.targetRotation = Math.atan2(moveX, moveZ);
                        let rotDiff = game.player.targetRotation - game.player.rotation;
                        // Normalize angle difference to be within -PI to PI
                        if (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                        if (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                        game.player.rotation += rotDiff * 0.15; // Apply smoothing factor
                        game.player.mesh.rotation.y = game.player.rotation;
                    }
                }
            } else {
                // If not moving, revert to idle, unless an attack/cast animation is active
                if (game.player.animationState !== 'attack' && game.player.animationState !== 'cast') {
                    game.player.animationState = 'idle';
                }
            }
            
            // Decrement player attack cooldown
            if (game.player.attackCooldown > 0) {
                game.player.attackCooldown--;
            }
            
            updateSpellEffects(); // Update active spell effects
            updateSpellCooldowns(); // Update UI cooldowns
        }

        // --- Camera Update ---
        // Separate function to control camera movement independently
        function updateCamera() {
            // Smoothly move the camera's look-at target towards the player's position
            // This creates the "lagging" effect for revealing more of the map
            game.cameraCurrentLookAt.lerp(game.player.position, game.cameraLerpFactor);

            // Calculate the camera's actual position based on the smoothed look-at target
            // and the fixed isometric offset.
            game.camera.position.set(
                game.cameraCurrentLookAt.x + game.cameraOffset.x,
                game.cameraCurrentLookAt.y + game.cameraOffset.y, 
                game.cameraCurrentLookAt.z + game.cameraOffset.z
            );
            
            // Always make the camera look at the smoothed look-at target
            game.camera.lookAt(game.cameraCurrentLookAt);
        }

        // --- Enemy Logic ---
        function updateEnemies() {
            const currentTime = Date.now();
            
            // Iterate through enemies in reverse to safely remove them
            for (let i = game.enemies.length - 1; i >= 0; i--) {
                const enemy = game.enemies[i];
                
                // Calculate distance to player
                const dx = game.player.position.x - enemy.position.x;
                const dz = game.player.position.z - enemy.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                // Move enemy towards player if not too close
                if (distance > 2) { // Keep a small distance to prevent overlapping
                    enemy.position.x += (dx / distance) * enemy.userData.speed;
                    enemy.position.z += (dz / distance) * enemy.userData.speed;
                } else if (currentTime - enemy.userData.lastAttack > 1000) {
                    // Attack player if close enough and attack cooldown is over
                    damagePlayer(enemy.userData.attackDamage);
                    enemy.userData.lastAttack = currentTime;
                }
                
                // Check if enemy is dead
                if (enemy.userData.health <= 0) {
                    game.scene.remove(enemy); // Remove from scene
                    game.enemies.splice(i, 1); // Remove from array
                    gainXP(enemy.userData.xpValue); // Grant XP to player
                    
                    // Spawn a new enemy after a short delay
                    setTimeout(createEnemy, 2000);
                }
            }
            
            updateEnemyCount(); // Update enemy count in UI
        }

        // --- Combat Functions ---
        function attackEnemy(enemy) {
            if (game.player.attackCooldown > 0) return; // Prevent attacking while on cooldown
            
            const distance = game.player.position.distanceTo(enemy.position);
            if (distance > 5) return; // Only attack if enemy is within range
            
            const damage = 15 + Math.floor(Math.random() * 10); // Randomize damage
            enemy.userData.health -= damage; // Apply damage to enemy
            
            // Visual feedback: brief white flash on enemy
            enemy.userData.body.material.color.setHex(0xffffff);
            enemy.userData.head.material.color.setHex(0xffffff);
            setTimeout(() => {
                if (enemy.userData.health > 0) { // Only revert color if not dead
                    enemy.userData.body.material.color.setHex(0xff3333);
                    enemy.userData.head.material.color.setHex(0xff1111);
                }
            }, 100);
            
            showDamageText(damage, enemy.position); // Display floating damage text
            game.player.attackCooldown = PLAYER_ATTACK_COOLDOWN_FRAMES; // Set cooldown frames

            // Trigger attack animation
            game.player.animationState = 'attack';
            game.player.animationTimers.attack.active = true;
            game.player.animationTimers.attack.startTime = Date.now();
            game.player.animationTimers.attack.currentFrame = 0; // Start from first attack frame
        }

        // --- Spell System ---
        function castSpell(spellType, targetPosition = null) {
            const spell = game.spells.types[spellType];
            if (!spell) return false; // Spell type not found
            
            // Check cooldown
            const currentTime = Date.now();
            if (game.spells.cooldowns[spellType] && currentTime < game.spells.cooldowns[spellType]) {
                return false; // Spell is on cooldown
            }
            
            // Check mana
            if (game.player.mana < spell.manaCost) {
                return false; // Not enough mana
            }
            
            // Consume mana and set cooldown
            game.player.mana -= spell.manaCost;
            game.spells.cooldowns[spellType] = currentTime + spell.cooldown;

            // Trigger spell cast animation for all spells (could be differentiated later)
            game.player.animationState = 'cast';
            game.player.animationTimers.spell.active = true;
            game.player.animationTimers.spell.startTime = Date.now();
            game.player.animationTimers.spell.currentFrame = 0; // Start from first cast frame
            
            // If spell is targeted and no specific target position is provided (e.g., from UI button click)
            if (spell.targeted && !targetPosition) {
                // Find nearest enemy within range
                let nearestEnemy = null;
                let nearestDist = Infinity;
                game.enemies.forEach(enemy => {
                    const dist = game.player.position.distanceTo(enemy.position);
                    if (dist < nearestDist && dist <= spell.range) {
                        nearestDist = dist;
                        nearestEnemy = enemy;
                    }
                });

                if (nearestEnemy) {
                    targetPosition = nearestEnemy.position.clone();
                } else {
                    // If no enemy, target a point directly in front of the player
                    const forwardVector = new THREE.Vector3(0, 0, 1);
                    // Apply player's conceptual rotation to the forward vector
                    const tempQuaternion = new THREE.Quaternion();
                    // For a THREE.Sprite, its quaternion is not relevant for its facing direction,
                    // but game.player.rotation holds the conceptual facing direction for spell targeting.
                    tempQuaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), game.player.rotation);
                    forwardVector.applyQuaternion(tempQuaternion);
                    targetPosition = game.player.position.clone().add(forwardVector.multiplyScalar(spell.range / 2));
                    targetPosition.y = 0; // Ensure target is on ground level
                }
            }

            // Cast the specific spell based on type
            switch (spellType) {
                case 'fireball':
                    castFireball(targetPosition);
                    break;
                case 'icestorm':
                    castIceStorm(targetPosition);
                    break;
                case 'lightning':
                    castLightning(targetPosition);
                    break;
                case 'teleport':
                    castTeleport(targetPosition);
                    break;
                case 'shield':
                    castShield();
                    break;
                case 'meteor':
                    castMeteor(targetPosition);
                    break;
            }
            
            updateUI(); // Update UI after mana consumption/cooldown set
            return true;
        }

        function castFireball(targetPosition) {
            if (!targetPosition) return; // A target position is required for fireball
            
            // Create fireball projectile with a trail/glow effect
            const fireballGeometry = new THREE.SphereGeometry(0.4, 12, 12);
            const fireballMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff4400, // Fiery orange
                transparent: true,
                opacity: 0.9
            });
            const fireball = new THREE.Mesh(fireballGeometry, fireballMaterial);
            
            // Add a larger, semi-transparent sphere for glowing effect
            const glowGeometry = new THREE.SphereGeometry(0.6, 8, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff8800, // Lighter orange for glow
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            fireball.add(glow); // Add glow as a child of fireball
            
            fireball.position.copy(game.player.position); // Start at player's position
            fireball.position.y += 0.5; // Lift slightly above player's center for visual origin
            
            // Calculate direction vector towards target
            const direction = targetPosition.clone().sub(fireball.position).normalize();
            
            // Define the effect properties
            const effect = {
                type: 'projectile',
                mesh: fireball,
                direction: direction,
                speed: 0.6,
                damage: game.spells.types.fireball.damage,
                lifetime: 0,
                maxLifetime: 120, // Max frames before despawn
                rotationSpeed: 0.2 // For visual rotation
            };
            
            game.effects.push(effect); // Add to active effects
            game.scene.add(fireball); // Add fireball to scene
        }

        function castIceStorm(targetPosition) {
            if (!targetPosition) targetPosition = game.player.position.clone(); // If no target, use player's position
            
            // Create multiple ice shards in a spiral/random pattern
            for (let i = 0; i < 15; i++) {
                setTimeout(() => { // Stagger the creation of shards
                    const angle = (i / 15) * Math.PI * 4; // Creates a double spiral
                    const radius = 1 + (i * 0.4); // Shards spread out as they are created
                    const icePosition = targetPosition.clone();
                    icePosition.x += Math.cos(angle) * radius;
                    icePosition.z += Math.sin(angle) * radius;
                    icePosition.y = 3; // Start high in the air
                    
                    const iceGeometry = new THREE.ConeGeometry(0.4, 1.5, 8); // Cone shape for ice shard
                    const iceMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x88ddff, // Light blue
                        transparent: true,
                        opacity: 0.8
                    });
                    const ice = new THREE.Mesh(iceGeometry, iceMaterial);
                    ice.position.copy(icePosition);
                    ice.rotation.x = Math.PI; // Point cone downwards
                    
                    // Add a sparkling crystal effect to each shard
                    const crystalGeometry = new THREE.OctahedronGeometry(0.2);
                    const crystalMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xaaffff, // Lighter, more transparent blue
                        transparent: true,
                        opacity: 0.6
                    });
                    const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                    crystal.position.set(0, 0.8, 0); // Position above ice shard base
                    ice.add(crystal);
                    
                    const effect = {
                        type: 'ice_shard',
                        mesh: ice,
                        targetY: 0.5, // Target Y position for impact
                        fallSpeed: 0.1,
                        damage: game.spells.types.icestorm.damage,
                        lifetime: 0,
                        maxLifetime: 150,
                        hasHit: new Set(), // Keep track of enemies already hit by this shard
                        rotationSpeed: 0.1
                    };
                    
                    game.effects.push(effect);
                    game.scene.add(ice);
                }, i * 50); // 50ms delay between each shard
            }
        }

        function castLightning(targetPosition) {
            // Chain lightning effect - hits up to a few enemies in succession
            let targets = [];
            let currentPos = game.player.position.clone();
            
            // Find enemies to chain to
            for (let chain = 0; chain < 3; chain++) { // Max 3 chain targets
                let nearestEnemy = null;
                let nearestDist = Infinity;
                
                game.enemies.forEach(enemy => {
                    // Ensure enemy hasn't already been targeted in this chain
                    if (!targets.includes(enemy)) {
                        const dist = currentPos.distanceTo(enemy.position);
                        if (dist < nearestDist && dist <= game.spells.types.lightning.range) {
                            nearestDist = dist;
                            nearestEnemy = enemy;
                        }
                    }
                });
                
                if (nearestEnemy) {
                    targets.push(nearestEnemy);
                    currentPos = nearestEnemy.position.clone(); // Next chain starts from this enemy's position
                } else {
                    break; // No more enemies to chain to
                }
            }
            
            // Create visual lightning bolts between chained targets
            let prevPos = game.player.position.clone();
            targets.forEach((target, index) => {
                setTimeout(() => { // Stagger the lightning strikes
                    // Deal damage, reduced for subsequent targets
                    const damage = game.spells.types.lightning.damage * (1 - index * 0.2); 
                    target.userData.health -= damage;
                    showDamageText(Math.floor(damage), target.position);
                    
                    // Visual lightning bolt geometry and material
                    const distance = prevPos.distanceTo(target.position);
                    const lightningGeometry = new THREE.CylinderGeometry(0.15, 0.05, distance, 6); // Tapered cylinder
                    const lightningMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffff99, // Pale yellow/white
                        transparent: true,
                        opacity: 0.9
                    });
                    const lightning = new THREE.Mesh(lightningGeometry, lightningMaterial);
                    
                    // Position the lightning bolt between current and previous point
                    const midPoint = prevPos.clone().add(target.position).multiplyScalar(0.5);
                    lightning.position.copy(midPoint);
                    lightning.lookAt(target.position); // Orient towards target
                    lightning.rotateX(Math.PI / 2); // Correct orientation of cylinder
                    
                    // Add sparking effect at the target
                    const sparkGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                    const sparkMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff, // White spark
                        transparent: true,
                        opacity: 0.8
                    });
                    const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                    spark.position.copy(target.position);
                    spark.position.y += 1;
                    
                    const effect = {
                        type: 'lightning',
                        mesh: lightning,
                        spark: spark,
                        lifetime: 0,
                        maxLifetime: 20, // Short duration
                        flickerSpeed: 0.1
                    };
                    
                    game.effects.push(effect);
                    game.scene.add(lightning);
                    game.scene.add(spark);
                    
                    prevPos = target.position.clone(); // Update previous position for next chain
                }, index * 100); // 100ms delay between chain segments
            });
        }

        function castTeleport(targetPosition) {
            if (!targetPosition) return;
            
            const distance = game.player.position.distanceTo(targetPosition);
            // Only teleport if within range
            if (distance <= game.spells.types.teleport.range) {
                // Create departure portal effect
                const portalGeometry = new THREE.RingGeometry(0.5, 1.5, 16); // Ring shape
                const portalMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x9900ff, // Purple
                    transparent: true,
                    opacity: 0.7
                });
                const departPortal = new THREE.Mesh(portalGeometry, portalMaterial);
                departPortal.position.copy(game.player.position);
                departPortal.rotation.x = -Math.PI / 2; // Lay flat on ground
                
                // Create arrival portal (clone of departure)
                const arrivalPortal = departPortal.clone();
                arrivalPortal.position.copy(targetPosition);
                arrivalPortal.position.y = 0.1; // Slightly above ground
                
                game.scene.add(departPortal);
                game.scene.add(arrivalPortal);
                
                // Temporarily make player mesh transparent for teleport effect
                if (game.player.mesh && game.player.mesh.material) {
                    game.player.mesh.material.opacity = 0.2;
                    game.player.mesh.material.transparent = true;
                }
                
                setTimeout(() => { // After a short delay, move player
                    game.player.position.copy(targetPosition);
                    // Ensure player's Y position is correct for its mesh type (e.g., center of sprite)
                    if (game.player.mesh && game.player.mesh instanceof THREE.Sprite) {
                        game.player.position.y = game.player.mesh.scale.y / 2; 
                    } else { // Fallback 3D mesh (if the sprite failed to load)
                        game.player.position.y = 1; // Center of 2-unit cylinder
                    }
                    game.player.mesh.position.copy(game.player.position);
                    updateCamera(); // Update camera to new player position
                    
                    // Restore player visibility
                    if (game.player.mesh && game.player.mesh.material) {
                        game.player.mesh.material.opacity = 1;
                        game.player.mesh.material.transparent = false;
                    }
                    
                    // Remove portals from scene
                    game.scene.remove(departPortal);
                    game.scene.remove(arrivalPortal);
                }, 200);
            }
        }

        function castShield() {
            // Create layered shield effect around the player
            const shieldLayers = [];
            
            for (let i = 0; i < 3; i++) {
                const radius = 1.2 + (i * 0.3); // Increasing radius for layered look
                const shieldGeometry = new THREE.RingGeometry(radius, radius + 0.2, 12); // Thick ring shape
                const shieldMaterial = new THREE.MeshBasicMaterial({ 
                    color: i === 0 ? 0x00aaff : i === 1 ? 0x0088cc : 0x006699, // Varying shades of blue
                    transparent: true,
                    opacity: 0.4 - (i * 0.1), // Varying opacity
                    side: THREE.DoubleSide // Render both sides of the ring
                });
                const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
                shield.position.copy(game.player.position); // Shield follows player (centered on player)
                shield.rotation.x = -Math.PI / 2; // Lay flat on ground
                
                shieldLayers.push(shield);
                game.scene.add(shield);
            }
            
            const effect = {
                type: 'shield',
                meshes: shieldLayers,
                lifetime: 0,
                maxLifetime: game.spells.types.shield.duration / (1000 / 60), // Convert ms duration to frames
                rotationSpeeds: [0.02, -0.03, 0.04], // Different rotation speeds for each layer
                pulseSpeed: 0.05 // For pulsing effect
            };
            
            game.effects.push(effect);
        }

        function castMeteor(targetPosition) {
            if (!targetPosition) return;
            
            // Create warning area on the ground before meteor strikes
            const warningGeometry = new THREE.RingGeometry(2.5, 3.5, 20);
            const warningMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff3300, // Red warning ring
                transparent: true,
                opacity: 0.4
            });
            const warning = new THREE.Mesh(warningGeometry, warningMaterial);
            warning.position.copy(targetPosition);
            warning.position.y = 0.1; // Slightly above ground
            warning.rotation.x = -Math.PI / 2;
            
            // Add inner warning circle
            const innerWarningGeometry = new THREE.CircleGeometry(2.5, 16);
            const innerWarningMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff6600, // Orange inner circle
                transparent: true,
                opacity: 0.2
            });
            const innerWarning = new THREE.Mesh(innerWarningGeometry, innerWarningMaterial);
            innerWarning.position.copy(warning.position);
            innerWarning.position.y += 0.01; // Ensure it's rendered slightly above the ring
            innerWarning.rotation.x = -Math.PI / 2;
            
            game.scene.add(warning);
            game.scene.add(innerWarning);
            
            // Pulse warning effect
            let pulseTime = 0;
            const pulseInterval = setInterval(() => {
                pulseTime += 0.1;
                warning.material.opacity = 0.4 + Math.sin(pulseTime * 8) * 0.2;
                innerWarning.material.opacity = 0.2 + Math.sin(pulseTime * 6) * 0.1;
            }, 50); // Update every 50ms
            
            // Meteor falls after a delay
            setTimeout(() => {
                clearInterval(pulseInterval); // Stop pulsing
                game.scene.remove(warning); // Remove warning indicator
                game.scene.remove(innerWarning);
                
                // Create meteor with fire trail
                const meteorGeometry = new THREE.SphereGeometry(1.2, 12, 12); // Large sphere for meteor
                const meteorMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff2200, // Deep red
                    transparent: true,
                    opacity: 0.9
                });
                const meteor = new THREE.Mesh(meteorGeometry, meteorMaterial);
                meteor.position.copy(targetPosition);
                meteor.position.y = 25; // Start high in the sky
                
                // Add fire trail (cone shape)
                const trailGeometry = new THREE.ConeGeometry(0.8, 4, 8);
                const trailMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff8800, // Orange/yellow for trail
                    transparent: true,
                    opacity: 0.6
                });
                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                trail.position.set(0, 2, 0); // Position relative to meteor
                meteor.add(trail);
                
                const effect = {
                    type: 'meteor',
                    mesh: meteor,
                    targetY: 0, // Ground level
                    speed: 1.2, // Fall speed
                    damage: game.spells.types.meteor.damage,
                    hasExploded: false, // Flag to prevent multiple explosions
                    rotationSpeed: 0.3 // For meteor spin
                };
                
                game.effects.push(effect);
                game.scene.add(meteor);
            }, 2500); // 2.5 second delay before meteor falls
        }

        // --- Spell Effect Update Loop ---
        function updateSpellEffects() {
            for (let i = game.effects.length - 1; i >= 0; i--) {
                const effect = game.effects[i];
                effect.lifetime++; // Increment lifetime for duration tracking
                
                switch (effect.type) {
                    case 'projectile':
                        effect.mesh.position.add(effect.direction.clone().multiplyScalar(effect.speed));
                        effect.mesh.rotation.y += effect.rotationSpeed;
                        
                        // Pulsing glow effect for fireball's child (glow sphere)
                        if (effect.mesh.children[0]) {
                            effect.mesh.children[0].scale.setScalar(1 + Math.sin(effect.lifetime * 0.3) * 0.2);
                        }
                        
                        // Check collision with enemies for projectiles
                        game.enemies.forEach(enemy => {
                            if (effect.mesh && effect.mesh.position.distanceTo(enemy.position) < 1.2) {
                                enemy.userData.health -= effect.damage;
                                showDamageText(effect.damage, enemy.position);
                                
                                // Create explosion visual effect
                                const explosionGeometry = new THREE.SphereGeometry(2, 12, 12);
                                const explosionMaterial = new THREE.MeshBasicMaterial({ 
                                    color: 0xff8800,
                                    transparent: true,
                                    opacity: 0.6
                                });
                                const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                                explosion.position.copy(effect.mesh.position);
                                
                                const explosionEffect = {
                                    type: 'explosion',
                                    mesh: explosion,
                                    lifetime: 0,
                                    maxLifetime: 30
                                };
                                
                                game.effects.push(explosionEffect);
                                game.scene.add(explosion);
                                
                                // Remove projectile after hit
                                game.scene.remove(effect.mesh);
                                effect.mesh = null; // Clear reference to avoid re-processing
                            }
                        });
                        
                        // Remove projectile if it. exceeds its max lifetime
                        if (effect.lifetime > effect.maxLifetime || effect.mesh === null) {
                            if (effect.mesh) game.scene.remove(effect.mesh);
                            game.effects.splice(i, 1);
                        }
                        break;
                        
                    case 'ice_shard':
                        if (effect.mesh.position.y > effect.targetY) {
                            effect.mesh.position.y -= effect.fallSpeed;
                            effect.mesh.rotation.y += effect.rotationSpeed;
                            
                            // Rotate crystal child for sparkle
                            if (effect.mesh.children[0]) {
                                effect.mesh.children[0].rotation.y += 0.2;
                                effect.mesh.children[0].rotation.x += 0.15;
                            }
                        } else {
                            // On ground impact, check for damage to enemies in area
                            game.enemies.forEach(enemy => {
                                // Prevent hitting the same enemy multiple times
                                if (!effect.hasHit.has(enemy) && 
                                    effect.mesh.position.distanceTo(enemy.position) < 2) {
                                    enemy.userData.health -= effect.damage;
                                    showDamageText(effect.damage, enemy.position);
                                    effect.hasHit.add(enemy);
                                }
                            });
                        }
                        
                        if (effect.lifetime > effect.maxLifetime) {
                            game.scene.remove(effect.mesh);
                            game.effects.splice(i, 1);
                        }
                        break;
                        
                    case 'lightning':
                        // Flickering and scaling spark effect
                        effect.mesh.material.opacity = 0.9 + Math.sin(effect.lifetime * effect.flickerSpeed * 20) * 0.1;
                        effect.spark.scale.setScalar(1 + Math.sin(effect.lifetime * 0.8) * 0.3);
                        
                        if (effect.lifetime > effect.maxLifetime) {
                            game.scene.remove(effect.mesh);
                            game.scene.remove(effect.spark);
                            game.effects.splice(i, 1);
                        }
                        break;
                        
                    case 'shield':
                        effect.meshes.forEach((shield, index) => {
                            shield.position.copy(game.player.position); // Shield follows player (centered on player)
                            shield.rotation.z += effect.rotationSpeeds[index]; // Rotate layers
                            
                            // Pulsing effect by scaling
                            const pulse = 1 + Math.sin(effect.lifetime * effect.pulseSpeed) * 0.1;
                            shield.scale.setScalar(pulse);
                        });
                        
                        if (effect.lifetime > effect.maxLifetime) {
                            effect.meshes.forEach(shield => game.scene.remove(shield)); // Remove all shield layers
                            game.effects.splice(i, 1);
                        }
                        break;
                        
                    case 'meteor':
                        if (!effect.hasExploded) {
                            effect.mesh.position.y -= effect.speed; // Meteor falls
                            effect.mesh.rotation.y += effect.rotationSpeed;
                            effect.mesh.rotation.x += effect.rotationSpeed * 0.7; // Tumble effect
                            
                            if (effect.mesh.position.y <= effect.targetY) {
                                // On impact, deal area damage to enemies
                                game.enemies.forEach(enemy => {
                                    if (effect.mesh.position.distanceTo(enemy.position) < 5) { // Damage radius 5
                                        enemy.userData.health -= effect.damage;
                                        showDamageText(effect.damage, enemy.position);
                                    }
                                });
                                
                                // Create ground explosion rings
                                for (let ring = 0; ring < 3; ring++) {
                                    const ringGeometry = new THREE.RingGeometry(ring * 2, (ring + 1) * 2, 16);
                                    const ringMaterial = new THREE.MeshBasicMaterial({ 
                                        color: ring === 0 ? 0xff3300 : ring === 1 ? 0xff6600 : 0xff9900,
                                        transparent: true,
                                        opacity: 0.8
                                    });
                                    const explosionRing = new THREE.Mesh(ringGeometry, ringMaterial);
                                    explosionRing.position.copy(effect.mesh.position);
                                    explosionRing.rotation.x = -Math.PI / 2;
                                    
                                    const ringEffect = {
                                        type: 'explosion_ring',
                                        mesh: explosionRing,
                                        lifetime: 0,
                                        maxLifetime: 60,
                                        expansionSpeed: 0.1
                                    };
                                    
                                    game.effects.push(ringEffect);
                                    game.scene.add(explosionRing);
                                }
                                
                                effect.hasExploded = true; // Mark as exploded
                                effect.lifetime = 0; // Reset lifetime for fade out
                                effect.maxLifetime = 40;
                                effect.mesh.material.color.setHex(0xffaa00); // Change meteor color to burnt
                            }
                        } else {
                            // Meteor fades out after explosion
                            effect.mesh.scale.multiplyScalar(1.2);
                            effect.mesh.material.opacity = 1 - (effect.lifetime / effect.maxLifetime);
                            effect.mesh.material.transparent = true;
                            
                            if (effect.lifetime > effect.maxLifetime) {
                                game.scene.remove(effect.mesh);
                                game.effects.splice(i, 1);
                            }
                        }
                        break;
                        
                    case 'explosion':
                        // General explosion effect (expands and fades)
                        effect.mesh.scale.multiplyScalar(1.1);
                        effect.mesh.material.opacity = 1 - (effect.lifetime / effect.maxLifetime);
                        effect.mesh.material.transparent = true;
                        
                        if (effect.lifetime > effect.maxLifetime) {
                            game.scene.remove(effect.mesh);
                            game.effects.splice(i, 1);
                        }
                        break;
                        
                    case 'explosion_ring':
                        // Ring-based explosion effect (expands and fades)
                        effect.mesh.scale.multiplyScalar(1 + effect.expansionSpeed);
                        effect.mesh.material.opacity = 1 - (effect.lifetime / effect.maxLifetime);
                        
                        if (effect.lifetime > effect.maxLifetime) {
                            game.scene.remove(effect.mesh);
                            game.effects.splice(i, 1);
                        }
                        break;
                        
                    case 'visual': // Generic visual effect
                        if (effect.lifetime > effect.maxLifetime) {
                            game.scene.remove(effect.mesh);
                            game.effects.splice(i, 1);
                        }
                        break;
                }
            }
        }

        // --- Spell Cooldown and UI State Updates ---
        function updateSpellCooldowns() {
            const currentTime = Date.now();
            
            // Update UI for each spell slot
            const spellMappings = {
                'spell1': 'fireball',
                'spell2': 'icestorm',
                'spell3': 'lightning',
                'spell4': 'teleport'
            };
            
            for (const slotId in spellMappings) {
                const spellType = spellMappings[slotId];
                const actionSlot = document.getElementById(slotId);
                
                if (actionSlot) {
                    const cooldownDiv = actionSlot.querySelector('.action-cooldown');
                    
                    // Check if spell is on cooldown
                    if (game.spells.cooldowns[spellType] && currentTime < game.spells.cooldowns[spellType]) {
                        const remaining = Math.ceil((game.spells.cooldowns[spellType] - currentTime) / 1000);
                        cooldownDiv.textContent = remaining;
                        cooldownDiv.style.display = 'flex';
                        actionSlot.classList.add('on-cooldown');
                    } else {
                        cooldownDiv.style.display = 'none';
                        actionSlot.classList.remove('on-cooldown');
                    }
                    
                    // Check mana requirements
                    if (game.player.mana < game.spells.types[spellType].manaCost) {
                        actionSlot.classList.add('insufficient-mana');
                    } else {
                        actionSlot.classList.remove('insufficient-mana');
                    }
                }
            }
            
            // Update basic attack and special attack button states
            const attackBtn = document.getElementById('attackBtn');
            const specialBtn = document.getElementById('specialBtn');
            
            if (attackBtn) {
                if (game.player.attackCooldown > 0) {
                    attackBtn.classList.add('on-cooldown'); // Use on-cooldown class for attack too
                } else {
                    attackBtn.classList.remove('on-cooldown');
                }
            }
            
            if (specialBtn) {
                if (game.player.mana < 20) { // Special attack cost
                    specialBtn.classList.add('insufficient-mana');
                } else {
                    specialBtn.classList.remove('insufficient-mana');
                }
            }
        }

        // --- Player Abilities ---
        function attackNearestEnemy() {
            if (game.player.attackCooldown > 0) return; // Cannot attack if on cooldown
            
            let nearest = null;
            let nearestDist = Infinity;
            
            // Find the nearest enemy within attack range
            game.enemies.forEach(enemy => {
                const dist = game.player.position.distanceTo(enemy.position);
                if (dist < nearestDist && dist <= 5) { // Range 5 units
                    nearestDist = dist;
                    nearest = enemy;
                }
            });
            
            if (nearest) {
                attackEnemy(nearest);
            }
        }

        function specialAttack() {
            const manaCost = 20;
            if (game.player.mana < manaCost) return; // Not enough mana
            
            game.player.mana -= manaCost; // Consume mana
            updateUI();
            
            // Trigger cast animation for special attack as well
            game.player.animationState = 'cast';
            game.player.animationTimers.spell.active = true;
            game.player.animationTimers.spell.startTime = Date.now();
            game.player.animationTimers.spell.currentFrame = 0;

            // Deal area damage to enemies around the player
            game.enemies.forEach(enemy => {
                const distance = game.player.position.distanceTo(enemy.position);
                if (distance < 8) { // Area of effect radius 8
                    const damage = 25 + Math.floor(Math.random() * 15); // Randomize damage
                    enemy.userData.health -= damage;
                    showDamageText(damage, enemy.position);
                    
                    // Visual feedback on hit enemies: brief yellow flash
                    enemy.userData.body.material.color.setHex(0xffff00);
                    enemy.userData.head.material.color.setHex(0xffff00);
                    setTimeout(() => {
                        if (enemy.userData.health > 0) {
                            enemy.userData.body.material.color.setHex(0xff3333);
                            enemy.userData.head.material.color.setHex(0xff1111);
                        }
                    }, 300);
                }
            });
        }

        // --- Health & Experience ---
        function damagePlayer(damage) {
            game.player.health -= damage;
            if (game.player.health < 0) game.player.health = 0; // Prevent negative health
            
            // Visual feedback: player sprite flashes red
            if (game.player.mesh && game.player.mesh.material) {
                // Store original color (usually white for sprites using map texture) to revert to
                const originalColor = game.player.mesh.material.color.clone();
                game.player.mesh.material.color.setHex(0xff0000); // Tint sprite red
                setTimeout(() => {
                    if (game.player.mesh && game.player.mesh.material) { // Check again in case player was removed/recreated
                        game.player.mesh.material.color.copy(originalColor); // Revert to original tint (white)
                    }
                }, 200);
            }
            
            updateUI();
            
            if (game.player.health <= 0) {
                showGameOver(); // Display game over message
            }
        }

        function gainXP(amount) {
            game.player.xp += amount;
            
            if (game.player.xp >= game.player.xpNext) {
                levelUp(); // Trigger level up if enough XP
            }
            
            updateUI();
        }

        function levelUp() {
            game.player.level++;
            game.player.xp = 0;
            game.player.xpNext = Math.floor(game.player.xpNext * 1.5); // Increase XP requirement for next level
            game.player.maxHealth += 10; // Increase max health
            game.player.health = game.player.maxHealth; // Restore full health
            game.player.maxMana += 5; // Increase max mana
            game.player.mana = game.player.maxMana; // Restore full mana
            
            // Visual feedback: player sprite flashes yellow
            if (game.player.mesh && game.player.mesh.material) {
                const originalColor = game.player.mesh.material.color.clone();
                game.player.mesh.material.color.setHex(0xffff00); // Tint sprite yellow
                setTimeout(() => {
                    if (game.player.mesh && game.player.mesh.material) {
                        game.player.mesh.material.color.copy(originalColor); // Revert to original tint (white)
                    }
                }, 1000);
            }
            
            updateUI();
        }

        // --- UI Feedback ---
        function showDamageText(damage, position) {
            const damageDiv = document.createElement('div');
            damageDiv.className = 'damage-text';
            damageDiv.textContent = Math.floor(damage).toString(); // Display integer damage
            
            // Convert 3D world position to 2D screen position for UI text
            const vector = position.clone();
            vector.project(game.camera); // Project 3D point to 2D normalized device coordinates
            
            const rect = game.renderer.domElement.getBoundingClientRect();
            damageDiv.style.left = ((vector.x + 1) / 2 * rect.width + Math.random() * 20 - 10) + 'px'; // Add slight random offset
            damageDiv.style.top = (-(vector.y - 1) / 2 * rect.height + Math.random() * 20 - 10) + 'px';
            
            document.getElementById('ui').appendChild(damageDiv);
            
            // Remove text after animation
            setTimeout(() => {
                if (damageDiv.parentNode) {
                    damageDiv.parentNode.removeChild(damageDiv);
                }
            }, 1000);
        }

        // --- Core UI Updates ---
        function updateUI() {
            const healthPercent = (game.player.health / game.player.maxHealth) * 100;
            const manaPercent = (game.player.mana / game.player.maxMana) * 100;
            
            document.getElementById('healthFill').style.width = healthPercent + '%';
            document.getElementById('manaFill').style.width = manaPercent + '%';
            document.getElementById('level').textContent = game.player.level;
            document.getElementById('xp').textContent = game.player.xp;
            document.getElementById('xpNext').textContent = game.player.xpNext;
        }

        function updateEnemyCount() {
            document.getElementById('enemyCount').textContent = game.enemies.length;
        }

        function regenerate() {
            // Mana regeneration
            if (game.player.mana < game.player.maxMana) {
                game.player.mana += 0.2; 
                if (game.player.mana > game.player.maxMana) {
                    game.player.mana = game.player.maxMana;
                }
            }
            
            // Health regeneration (slower)
            if (game.player.health < game.player.maxHealth) {
                game.player.health += 0.05;
                if (game.player.health > game.player.maxHealth) {
                    game.player.health = game.player.maxHealth;
                }
            }
            
            updateUI();
        }

        function showGameOver() {
            document.getElementById('gameOverMessage').style.display = 'flex'; // Show overlay
        }

        function restartGame() {
            // Reset player stats
            game.player.health = game.player.maxHealth = INITIAL_PLAYER_HEALTH;
            game.player.mana = game.player.maxMana = INITIAL_PLAYER_MANA;
            game.player.level = 1;
            game.player.xp = 0;
            game.player.xpNext = INITIAL_PLAYER_XP_NEXT;
            game.player.attackCooldown = 0;

            // Reset player's position and appearance
            if (game.player.mesh) {
                // Determine the correct Y position based on current mesh type (sprite or fallback 3D)
                let initialPlayerY = 0;
                if (game.player.mesh instanceof THREE.Sprite) {
                    initialPlayerY = game.player.mesh.scale.y / 2; // Half height for sprite center
                } else if (game.player.mesh instanceof THREE.Mesh) {
                    // Assuming fallback cylinder is height 2, center at Y=1
                    initialPlayerY = 1; 
                }
                game.player.position.set(0, initialPlayerY, 0); // Reset XZ, keep correct Y
                game.player.mesh.position.copy(game.player.position);
                
                // If the sprite was tinted (from damage/level up), reset its color tint to white (original texture color)
                if (game.player.mesh.material && game.player.mesh.material.map) {
                    game.player.mesh.material.color.setHex(0xffffff); 
                } else if (game.player.mesh.material) { // Fallback 3D model
                    game.player.mesh.material.color.setHex(0x0066ff); // Original blue color for fallback
                }
            }
            // Reset animation state and frame
            game.player.animationState = 'idle';
            game.player.currentFrame = 0;
            game.player.frameCounter = 0;
            game.player.animationTimers.attack.active = false;
            game.player.animationTimers.spell.active = false;
            if (game.player.mesh) {
                setFrame(game.player.mesh, game.player.animationSequences.idle[0]);
            }


            // Clear enemies
            game.enemies.forEach(enemy => game.scene.remove(enemy));
            game.enemies = [];

            // Clear effects
            game.effects.forEach(effect => {
                if (effect.mesh) game.scene.remove(effect.mesh);
                if (effect.meshes) effect.meshes.forEach(m => game.scene.remove(m));
                if (effect.spark) game.scene.remove(effect.spark);
            });
            game.effects = [];

            // Reset spell cooldowns
            game.spells.cooldowns = {};

            // Spawn new enemies
            for (let i = 0; i < 5; i++) {
                createEnemy();
            }

            updateUI();
            
            // --- Camera Fix: Reset camera look-at position on game restart ---
            game.cameraCurrentLookAt.copy(game.player.position);
            updateCamera(); // Call updateCamera to immediately apply changes
            // --- End Camera Fix ---

            document.getElementById('gameOverMessage').style.display = 'none'; // Hide overlay
            console.log('Game restarted!');
        }

        // --- Mobile Controls ---
        function initMobileControls() {
            const joystick = document.getElementById('virtualJoystick');
            const knob = document.getElementById('joystickKnob');
            const actionBar = document.querySelector('.action-bar');
            
            let joystickActive = false;
            let joystickCenter = { x: 0, y: 0 };
            const maxDistance = 100; // Increased max distance to match the doubled joystick size (240px width / 2 = 120px radius; half of that for knob movement: 60px; original was 50px, so 100px is roughly double for a 240px joystick)
            
            // Joystick touch/mouse start
            function startJoystick(e) {
                joystickActive = true;
                const rect = joystick.getBoundingClientRect();
                joystickCenter.x = rect.left + rect.width / 2;
                joystickCenter.y = rect.top + rect.height / 2;
                e.preventDefault(); // Prevent default browser actions like scrolling
            }
            
            // Joystick touch/mouse move
            function moveJoystick(e) {
                if (!joystickActive) return;
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                let deltaX = clientX - joystickCenter.x;
                let deltaY = clientY - joystickCenter.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Limit knob movement to maxDistance
                if (distance > maxDistance) {
                    deltaX = (deltaX / distance) * maxDistance;
                    deltaY = (deltaY / distance) * maxDistance;
                }
                
                game.mobile.joystick.deltaX = deltaX / maxDistance; // Normalize to -1 to 1
                game.mobile.joystick.deltaY = deltaY / maxDistance;
                knob.style.transform = `translate(-50%, -50%) translate(${deltaX}px, ${deltaY}px)`; // Move knob visually
                
                e.preventDefault();
            }
            
            // Joystick touch/mouse end
            function endJoystick(e) {
                joystickActive = false;
                game.mobile.joystick.deltaX = 0;
                game.mobile.joystick.deltaY = 0;
                knob.style.transform = 'translate(-50%, -50%)'; // Reset knob position
                e.preventDefault();
            }
            
            // Attach touch and mouse event listeners for joystick
            joystick.addEventListener('touchstart', startJoystick, { passive: false });
            document.addEventListener('touchmove', moveJoystick, { passive: false });
            document.addEventListener('touchend', endJoystick, { passive: false });
            
            joystick.addEventListener('mousedown', startJoystick);
            document.addEventListener('mousemove', moveJoystick);
            document.addEventListener('mouseup', endJoystick);

            // Attach click/touch listeners to action bar buttons
            actionBar.querySelectorAll('.action-slot').forEach(button => {
                button.addEventListener('click', (e) => {
                    e.preventDefault(); // Prevent double clicks on mobile
                    const actionType = button.dataset.action;
                    const spellType = button.dataset.spell;

                    if (actionType === 'attack') {
                        attackNearestEnemy();
                    } else if (actionType === 'special') {
                        specialAttack();
                    } else if (spellType) {
                        castSpell(spellType); // Cast spell (will auto-target if mobile)
                    }
                });
                // Also add touchstart for immediate response on mobile
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent tap delay
                    const actionType = button.dataset.action;
                    const spellType = button.dataset.spell;

                    if (actionType === 'attack') {
                        attackNearestEnemy();
                    } else if (actionType === 'special') {
                        specialAttack();
                    } else if (spellType) {
                        castSpell(spellType); // Cast spell
                    }
                }, { passive: false });
            });
        }

        // --- Event Listeners ---
        function initEventListeners() {
            // Keyboard input
            document.addEventListener('keydown', (e) => {
                game.keys[e.key.toLowerCase()] = true; // Store key state as lowercase
                
                // Spell hotkeys (1, 2, 3, 4)
                if (e.key === '1') castSpell('fireball');
                if (e.key === '2') castSpell('icestorm');
                if (e.key === '3') castSpell('lightning');
                if (e.key === '4') castSpell('teleport');

                // Attack and special hotkeys
                if (e.key.toLowerCase() === 'q') attackNearestEnemy();
                if (e.key.toLowerCase() === 'e') specialAttack();
                
                // Fullscreen hotkey
                if (e.key.toLowerCase() === 'f') toggleFullscreen();

                if (e.key === ' ') e.preventDefault(); // Prevent spacebar from scrolling
            });

            document.addEventListener('keyup', (e) => {
                game.keys[e.key.toLowerCase()] = false;
            });

            // Fullscreen button click
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);

            // Restart Game button click
            document.getElementById('restartButton').addEventListener('click', restartGame);

            // Mouse/Touch for spell targeting on the ground (desktop right-click, mobile tap)
            game.renderer.domElement.addEventListener('contextmenu', (e) => {
                e.preventDefault(); // Prevent default right-click context menu
                handleTargetedClick(e, 'right');
            });
            
            // For general clicks on the canvas (can be used for targeted spells on mobile)
            game.renderer.domElement.addEventListener('click', (e) => {
                 // Check if the click originated from an action bar button, if so, ignore.
                 // This prevents accidental spell casts on the ground when tapping action bar.
                if (e.target.closest('.action-slot')) return;
                handleTargetedClick(e, 'left');
            });
            // For mobile touch events specifically
            game.renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1 && !e.target.closest('.action-slot') && !e.target.closest('.virtual-joystick')) {
                     // Only handle single touch outside of controls for targeting
                    handleTargetedClick(e, 'touch');
                }
            }, { passive: false });

            // --- Comprehensive Resize and Fullscreen Handling ---
            function handleResize() {
                // Set CSS custom property for real viewport height (important for mobile)
                if (game.mobile.isMobile) {
                    const vh = window.innerHeight * 0.01;
                    document.documentElement.style.setProperty('--vh', `${vh}px`);
                    // Also explicitly set the gameContainer height again
                    document.getElementById('gameContainer').style.height = `calc(var(--vh, 1vh) * 100)`;
                    document.getElementById('ui').style.height = `calc(var(--vh, 1vh) * 100)`;
                }

                // Get current viewport dimensions
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                console.log('Resizing to:', width, 'x', height);
                
                // Update camera aspect ratio
                game.camera.aspect = width / height;
                game.camera.updateProjectionMatrix(); // Recalculate camera's projection matrix
                
                // Update renderer size - force update
                game.renderer.setSize(width, height, false);
                
                // Ensure canvas fills the container explicitly
                const canvas = game.renderer.domElement;
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                
                // Update camera position based on new aspect ratio
                updateCamera();
                
                // Force a render to see changes immediately
                game.renderer.render(game.scene, game.camera);
            }
            
            // Attach resize listener
            window.addEventListener('resize', handleResize);
            // Handle orientation changes on mobile
            window.addEventListener('orientationchange', () => {
                setTimeout(handleResize, 100); // Small delay for layout to settle
            });
            
            // Handle fullscreen changes (browser specific events)
            document.addEventListener('fullscreenchange', handleResize);
            document.addEventListener('webkitfullscreenchange', handleResize);
            document.addEventListener('mozfullscreenchange', handleResize);
            document.addEventListener('MSFullscreenChange', handleResize);
            
            // Handle visibility changes (e.g., when app comes back to foreground on mobile)
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    setTimeout(handleResize, 100);
                }
            });
            
            // Initial camera setup after all elements are loaded
            updateCamera();
        }

        // --- Targeted Click Handling ---
        function handleTargetedClick(e, clickType) {
            const rect = game.renderer.domElement.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            const mouse = new THREE.Vector2();
            // Convert mouse/touch coordinates to normalized device coordinates (-1 to +1)
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            game.raycaster.setFromCamera(mouse, game.camera); // Set raycaster origin and direction
            
            // Intersect with ground plane to find target position
            const intersects = game.raycaster.intersectObjects([game.groundMesh]);
            
            if (intersects.length > 0) {
                const targetPosition = intersects[0].point; // Get the 3D point of intersection
                targetPosition.y = 0; // Ensure spells are cast on the ground level.

                // If right-click (desktop), cast fireball.
                if (clickType === 'right') {
                    castSpell('fireball', targetPosition);
                } 
                // For left-click/touch, if no specific action, it implies a move or potential future targeted spell
                else if (clickType === 'left' || clickType === 'touch') {
                    // This could be extended to allow player to click-to-move, or target other spells.
                    // For now, it doesn't trigger a spell unless a hotkey was pressed.
                    // This section could be expanded for more direct targeting if needed,
                    // but the current action bar logic handles mobile targeting.
                }
            } else {
                 console.log("No ground intersected.");
            }
        }


        // --- Fullscreen Functionality ---
        function toggleFullscreen() {
            // Check if already in fullscreen mode
            if (!document.fullscreenElement && !document.webkitFullscreenElement && 
                !document.mozFullScreenElement && !document.msFullscreenElement) {
                // Enter fullscreen
                const element = document.documentElement; // Target the entire document
                if (element.requestFullscreen) {
                    element.requestFullscreen();
                } else if (element.webkitRequestFullscreen) { /* Safari */
                    element.webkitRequestFullscreen();
                } else if (element.mozRequestFullScreen) { /* Firefox */
                    element.mozRequestFullScreen();
                } else if (element.msRequestFullscreen) { /* IE11 */
                    element.msRequestFullscreen();
                }
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { /* Safari */
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) { /* Firefox */
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) { /* IE11 */
                    element.msExitFullscreen();
                }
            }
        }

        // --- Main Game Loop ---
        function animate() {
            // Request the next animation frame, creating a continuous loop
            requestAnimationFrame(animate); 
            
            handleInput(); // Process player input
            updateEnemies(); // Update enemy logic (movement, attacks)
            regenerate(); // Regenerate health and mana over time
            
            // --- Player Animation Update Logic ---
            if (game.player.mesh && game.player.spriteTexture) {
                const now = Date.now();
                let sequence = [];
                let frameDuration = 0;
                let currentAnimTimer = null;

                // Handle one-shot animations first (attack, spell)
                if (game.player.animationTimers.attack.active) {
                    currentAnimTimer = game.player.animationTimers.attack;
                    sequence = game.player.animationSequences.attack;
                    frameDuration = currentAnimTimer.duration / sequence.length;

                    const elapsed = now - currentAnimTimer.startTime;
                    const frameIndexInSequence = Math.floor(elapsed / frameDuration);

                    if (frameIndexInSequence < sequence.length) {
                        game.player.currentFrame = sequence[frameIndexInSequence];
                    } else {
                        // Animation finished, reset to idle/walk
                        currentAnimTimer.active = false;
                        if (Math.abs(game.mobile.joystick.deltaX) > 0.1 || Math.abs(game.mobile.joystick.deltaY) > 0.1 || Object.values(game.keys).some(v => v)) {
                            game.player.animationState = 'walk';
                        } else {
                            game.player.animationState = 'idle';
                        }
                    }
                } else if (game.player.animationTimers.spell.active) {
                    currentAnimTimer = game.player.animationTimers.spell;
                    sequence = game.player.animationSequences.cast;
                    frameDuration = currentAnimTimer.duration / sequence.length;

                    const elapsed = now - currentAnimTimer.startTime;
                    const frameIndexInSequence = Math.floor(elapsed / frameDuration);

                    if (frameIndexInSequence < sequence.length) {
                        game.player.currentFrame = sequence[frameIndexInSequence];
                    } else {
                        // Animation finished, reset to idle/walk
                        currentAnimTimer.active = false;
                        if (Math.abs(game.mobile.joystick.deltaX) > 0.1 || Math.abs(game.mobile.joystick.deltaY) > 0.1 || Object.values(game.keys).some(v => v)) {
                            game.player.animationState = 'walk';
                        } else {
                            game.player.animationState = 'idle';
                        }
                    }
                } else {
                    // Handle continuous animations (idle, walk)
                    sequence = game.player.animationSequences[game.player.animationState];
                    game.player.frameCounter++;
                    if (game.player.frameCounter >= (60 / game.player.frameRate)) { // Assuming 60fps, update frameRate times per second
                        game.player.frameCounter = 0;
                        const currentFrameIndexInSequence = game.player.animationSequences[game.player.animationState].indexOf(game.player.currentFrame);
                        const nextFrameIndexInSequence = (currentFrameIndexInSequence + 1) % sequence.length;
                        game.player.currentFrame = sequence[nextFrameIndexInSequence];
                    }
                }

                // Apply the determined frame to the sprite
                setFrame(game.player.mesh, game.player.currentFrame);
            }
            // --- End Player Animation Update Logic ---
            
            updateCamera(); // Update camera position after player movement
            game.renderer.render(game.scene, game.camera); // Render the 3D scene
        }

        // --- Game Initialization ---
        function initGame() {
            try {
                // Basic check to ensure Three.js library is loaded
                if (typeof THREE === 'undefined') {
                    throw new Error('Three.js library not found. Please check script inclusion.');
                }
                
                // Mobile viewport height fix: ensures 100vh works correctly on mobile browsers
                if (game.mobile.isMobile) {
                    function setViewportHeight() {
                        const vh = window.innerHeight * 0.01;
                        document.documentElement.style.setProperty('--vh', `${vh}px`);
                        // Also explicitly set the gameContainer height again
                        document.getElementById('gameContainer').style.height = `calc(var(--vh, 1vh) * 100)`;
                        document.getElementById('ui').style.height = `calc(var(--vh, 1vh) * 100)`;
                    }
                    setViewportHeight();
                    window.addEventListener('resize', setViewportHeight);
                    window.addEventListener('orientationchange', () => {
                        setTimeout(setViewportHeight, 100);
                    });
                }
                
                initThreeJS(); // Setup Three.js scene, camera, renderer
                createWorld(); // Build the game environment
                createPlayer(); // Create the player character (now a sprite)
                
                // --- Camera Fix: Initialize camera's look-at target to player's initial position ---
                game.cameraCurrentLookAt.copy(game.player.position);
                // --- End Camera Fix ---

                // Spawn initial enemies
                for (let i = 0; i < 5; i++) {
                    createEnemy();
                }
                
                initMobileControls(); // Setup virtual joystick and mobile action buttons
                initEventListeners(); // Setup all keyboard, mouse, touch, and resize listeners
                updateUI(); // Initial UI update

                // Background music
                // Browsers may prevent autoplay until user interacts with the page.
                const bgMusic = new Audio('audio/song1.mp3');
                bgMusic.loop = true;
                bgMusic.play().catch(error => console.log("Autoplay prevented: ", error));
                game.backgroundMusic = bgMusic;
                
                console.log('Diablo 3 Clone Game initialized successfully!');
                animate(); // Start the main game loop
                
            } catch (error) {
                // Display error message if game initialization fails
                console.error('Game initialization failed:', error);
                document.body.innerHTML = `
                    <div style="color: red; font-size: 20px; text-align: center; margin-top: 100px;">
                        Game failed to load: ${error.message}<br>
                        Please ensure Three.js is loaded and your browser supports WebGL.
                    </div>
                `;
            }
        }

        // Start the game when the window has fully loaded
        window.onload = initGame;
    </script>
</body>
</html>
